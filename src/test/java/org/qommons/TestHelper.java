package org.qommons;

import java.lang.reflect.Constructor;
import java.time.Duration;
import java.util.Random;
import java.util.function.Consumer;
import java.util.regex.Pattern;

import org.qommons.ArgumentParsing.ArgumentParser;
import org.qommons.ArgumentParsing.Arguments;

/**
 * <p>
 * This class may be used by test classes to generate pseudo-random numbers that would be used to generate pseudo-random test cases. These
 * test class would attempt to use the randomness to cover every possible permutation of code invocation in order to test a system
 * more-or-less completely.
 * </p>
 *
 * <p>
 * For example, to test a stateful class with 3 methods, a(int arg), b(boolean arg), and c(double arg), the class could do something like
 *
 * <pre>
 * (TestHelper helper) -> {
 * 	ToTest test = new ToTest();
 * 	int tries = 5000;
 * 	for (int i = 0; i &lt; tries; i++) {
 * 		switch (helper.getInt(0, 3)) {
 * 		case 0:
 * 			int intArg = helper.getInt(-1, 1000000); // Constrain to the expected argument range of method a()
 * 			assertOutputOfACorrect(intArg, a(intArg));
 * 			break;
 * 		case 1:
 * 			boolean boolArg = helper.getBoolean();
 * 			assertOutputOfBCorrect(boolArg, b(boolArg));
 * 			break;
 * 		case 2:
 * 			double doubleArg = helper.getDouble();
 * 			assertOutputOfCCorrect(doubleArg, C(doubleArg));
 * 			break;
 * 		}
 * 	}
 * }
 * </pre>
 *
 * This would generate 5000 random states in the tested class for each test case.
 * </p>
 * <p>
 * Far more than just a utility wrapper around {@link Random}, this class may be used to generate unlimited test cases that can be run
 * ad-infinitum. It keeps track of the history of each test case. It has several modes:
 * <ul>
 * <li><b>--random</b> In this mode, random test cases are generated and failures are logged for later reproduction. Options::
 * <ul>
 * <li><b>--max-cases=&lt;integer&gt;</b> The maximum number of test cases to run.</li>
 * <li><b>--max-time=&lt;duration&gt;</b> The maximum amount of time to run.</li>
 * <li><b>--max-failures=&lt;integer&gt;</b> The maximum number of failures to encounter.</li>
 * <li><b>--only-new=&lt;boolean&gt;</b> If true, this class will not re-attempt test cases that were last known to be broken. Default is
 * true.</li>
 * </ul>
 * </li>
 * <li><b>--reproduce</b> In this mode, tests that have broken recently are re-run. Options:
 * <ul>
 * <li><b>--debug</b> If this flag is set, the helper will invoke a break point (via {@link org.qommons.BreakpointHere}) just before the
 * most recent point of failure for each test.</li>
 * <li><b>--hash=&lt;debug-hash&gt;</b> The hash or comma-separated hashes to re-execute. If unspecified, all test cases that were last
 * known to be broken will be run.</li>
 * <li><b>--debug-at=&lt;long integer&gt;</b> The number of bytes in the test case at which to catch a breakpoint. Must be used with -hash
 * for a single hash.</li>
 * </ul>
 * </li>
 * </ul>
 * All modes have the following options:
 * <ul>
 * <li><b>--test-class=&lt;qualified.className&gt;</b> The {@link Testable} class to test. Must have a no-argument constructor.</li>
 * <li><b>--hold-time=&lt;duration&gt;</b> The maximum time to wait between invocations to this helper (if unspecified by execution) before
 * failure is assumed.</li>
 * </ul>
 * </p>
 * <p>
 * The console output of this class can be used to monitor the progress of the test. When each test case is started, the hash for that test
 * is printed immediately. When the test case finishes successfully, SUCCESS is printed, followed by the percent success for the current
 * testing session. Upon failure, FAILURE or TIMEOUT is printed, followed by "@" and the number of bytes generated by the helper for the
 * test case before its failure. This may be used (in conjunction with the -hash argument) in -reproduce mode with the -debug-at argument to
 * invoke a break point just prior to the failure. Then the stack trace of the exception or of the execution upon timeout is printed.
 * </p>
 */
public class TestHelper {
	public static interface Testable extends Consumer<TestHelper> {}

	private final long theSeed;
	private final Random theRandomness;
	private long theBytes;

	public TestHelper(){
		this(Double.doubleToLongBits(Math.random()), 0);
	}

	public TestHelper(long seed, long bytes) {
		theSeed=seed;
		theRandomness=new Random(seed);
		while (theBytes < bytes - 7)
			getAnyLong();
		while (theBytes < bytes)
			getByte();
	}

	public TestHelper fork() {}

	public void placemark() {}

	public TestHelper tolerate(Duration timeout) {}

	public int getAnyInt() {}

	public int getInt(int min, int max) {}

	public long getAnyLong() {}

	public long getLong(long min, long max) {}

	public double getDouble() {}

	public double getGaussian() {}

	public double getAnyDouble() {}

	public double getDouble(double min, double max) {}

	public boolean getBoolean() {}

	public byte getByte() {}

	public static void main(String[] args) {
		ArgumentParser parser = new ArgumentParser()//
			.forDefaultFlagPattern()//
			/**/.flagArg("random").requiredIfNot("reproduce")//
			/**/.flagArg("reproduce").requiredIfNot("random")//
			/**/.flagArg("debug").requires("reproduce")//
			/**/
			.forDefaultValuePattern()//
			/**/.stringArg("test-class").required()//
			/**/.durationArg("hold-time").defValue(Duration.ofSeconds(60))//
			/**/.intArg("max-cases").requires("random").atLeast(1)//
			/**/.durationArg("max-time").requires("random")//
			/**/.intArg("max-failures").requires("random").atLeast(1)//
			/**/.booleanArg("only-new").requires("random").defValue(true)//
			/**/.intArg("debug-at").atLeast(0)//
			.forDefaultMultiValuePattern()//
			/**/.patternArg("hash", Pattern.compile("[0-9a-fA-F]{16}"))//
			.getParser();
		Arguments parsed = parser.parse(args);
		Class<? extends Testable> testable;
		try {
			testable = Class.forName(parsed.getString("test-class")).asSubclass(Testable.class);
		} catch (ClassNotFoundException e) {
			System.err.println("Test class " + parsed.getString("test-class") + " not found");
			e.printStackTrace();
			return;
		}
		Constructor<? extends Testable> creator;
		try {
			try {
				creator = testable.getConstructor();
			} catch (NoSuchMethodException e) {
				creator = testable.getDeclaredConstructor();
			}
		} catch (NoSuchMethodException | SecurityException e) {
			System.err.println("Test class " + testable.getName() + " does not have a no-argument constructor");
			e.printStackTrace();
			return;
		}
		if (!creator.isAccessible()) {
			try {
				creator.setAccessible(true);
			} catch (SecurityException e) {
				System.err
				.println("No-argument constructor for test class " + testable.getName() + " is not accessible (try making it public)");
				e.printStackTrace();
				return;
			}
		}
		/* Write test case history to an XML file.  Attempt to co-locate this file with the class being tested.  If co-located, the file
		 * should be the simple name of the class.test.xml.  Otherwise make a sub-dir called testhelper under the current working dir and
		 * put the file in there, named fully.qualified.ClassName.test.xml.
		 *
		 */
	}
}
